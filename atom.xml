<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://adiaosdu.github.io</id>
    <title>Diao&apos;s Domain</title>
    <updated>2022-03-23T15:43:43.146Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://adiaosdu.github.io"/>
    <link rel="self" href="https://adiaosdu.github.io/atom.xml"/>
    <logo>https://adiaosdu.github.io/images/avatar.png</logo>
    <icon>https://adiaosdu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Diao&apos;s Domain</rights>
    <entry>
        <title type="html"><![CDATA[文献翻译（一）]]></title>
        <id>https://adiaosdu.github.io/post/uAsdaBKeE/</id>
        <link href="https://adiaosdu.github.io/post/uAsdaBKeE/">
        </link>
        <updated>2022-03-23T11:13:00.000Z</updated>
        <content type="html"><![CDATA[<p>Chirality, an intrinsic degree of freedom, has been <strong>barely</strong> exploited as the information carriers in data transmission, processing, computing, etc. Recently the magnons in antiferromagnets were proposed to carry both right-handed and left-handed chiralities, <strong>shedding a light on</strong> chirality-based spintronics in which chirality-based computing <strong>architectures</strong> and chiral magnonic devices may become feasible.<br>
手性作为一种固有的自由度，作为信息载体在数据传输、处理和计算等方面的研究很少。近年来，人们提出反铁磁体中的磁子可以同时携带右手性和左手性手性，这为基于手性的自旋电子学研究提供了新的思路，从而使基于手性的计算体系和手性磁子器件成为可能。</p>
<p>However, the practical platform for chirality-based spintronics <strong>remains absent yet</strong>. Here we report an artificial ferrimagnetic Py/Gd/Py/Gd/Py/Pt multilayer by which the switching, reading, and modulation of magnon chirality are demonstrated. In particular, the coexisting resonance modes of ferromagnetic and antiferromagnetic characteristics permit the high adjustability and easy control of magnon chirality.<br>
然而，基于手性的自旋电子学的实际平台仍然缺乏。本文报道了一种人造铁磁Py/Gd/Py/Gd/Py/ Pt多层膜，通过该多层膜可以实现磁子手性的开关、读取和调制。特别是，铁磁和反铁磁特性的共存共振模式使得磁子手性具有很高的可调性和易于控制。</p>
<p>As a main result, we unambiguously demonstrated that Py precessions with opposite chiralities pump spin currents of opposite spin polarizations into the Pt layer. Our result manifests the chirality as an independent degree of freedom and illustrates a practical magnonic platform for exploiting chirality, paving the way for chirality-based spintronics.<br>
作为主要结果，我们明确地证明了具有相反手性的Py旋进将相反自旋极化的自旋电流泵入Pt层。我们的研究结果表明手性是一个独立的自由度，为开发手性提供了一个实用的磁平台，为基于手性的自旋电子学铺平了道路。</p>
<blockquote>
<p>https://www.phy.pku.edu.cn/info/1031/7665.htm</p>
</blockquote>
<p>Controlling and programming quantum devices to process quantum information by the unit of quantum dit, i.e., qudit, provides the possibilities for <strong>noise-resilient</strong> quantum communications, delicate quantum molecular <strong>simulations</strong>, and efficient quantum computations, showing great potential to enhance the capabilities of qubit-based quantum technologies. Here, we report a programmable qudit-based quantum processor in silicon-photonic integrated circuits and demonstrate its enhancement of quantum computational parallelism.<br>
通过量子单元（高维量子位）来控制和编程量子设备来处理量子信息，为抗噪声量子通信、精细的量子分子模拟和高效的量子计算提供了可能性。显示出提升基于量子比特的量子技术能力的巨大潜力。在这里，我们报道了一种可编程的基于高维量子位的硅光子集成电路的量子处理器，并证明了它对量子计算并行性的增强。</p>
<p>The processor monolithically integrates all the key functionalities and capabilities of initialisation, manipulation, and measurement of the two quantum quart (ququart) states and multi-value quantum-controlled logic gates with high-level fidelities.<br>
该处理器集成了所有的关键功能，并具有初始化、操作和测量两夸脱量子状态和高保真下多值量子控制逻辑门的能力。</p>
<p>By reprogramming the configuration of the processor, we implemented the most basic quantum Fourier transform algorithms, all in quaternary, to benchmark the enhancement of quantum parallelism using qudits, which include generalised Deutsch-Jozsa and Bernstein-Vazirani algorithms, quaternary phase estimation and fast factorization algorithms.<br>
通过对处理器配置的重新编程，我们实现了最基本的量子傅里叶变换算法，使用高维量子位对增强的量子并行性进行基准测试，包括高维Deutsch-Jozsa和Bernstein-Vazirani算法、高维量子相位估算和高维Shor大数分解（求阶）算法。</p>
<p>The monolithic integration and high programmability have allowed the implementations of more than one million <strong>high-fidelity</strong> preparations, operations and projections of qudit states in the processor.<br>
单片集成和高可编程性允许在处理器中实现超过一百万次的高保真准备、操作和高维量子状态的投影。</p>
<p>Our work shows an integrated photonic quantum technology for qudit-based quantum computing with enhanced capacity, accuracy, and efficiency, which could lead to the acceleration of building a large-scale quantum computer.<br>
我们的工作展示了一种集成的光量子技术，可用于基于高维量子位的光量子计算，具有更高的容量、准确性和效率，这可能会引领加速新一代大规模量子计算机。</p>
<blockquote>
<p>https://www.phy.pku.edu.cn/info/1031/7304.htm</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机视觉与模式识别（一）]]></title>
        <id>https://adiaosdu.github.io/post/FYskBxyV_/</id>
        <link href="https://adiaosdu.github.io/post/FYskBxyV_/">
        </link>
        <updated>2022-03-23T07:18:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本系列博文整理自西安交通大学苏远歧老师课堂内容</p>
</blockquote>
<h3 id="人眼的成像系统">人眼的成像系统</h3>
<ul>
<li>视锥细胞：红 (L cone) 、 绿 (M cone) 和 蓝 (S cone) 三种锥体细胞对不同频率、不同亮度的光感知程度不同。每一种感光色素主要对一种原色光产生兴奋，而对其余两种原色光产生程度不等的反应。如果某一种色素缺乏，则会产生对此种颜色的感觉障碍，表现为色盲或色弱（辨色力弱）。</li>
<li>视杆细胞：对弱光敏感，负责在昏暗环境下产生视觉，辨别明暗</li>
<li>视觉暂留：当人眼所看到的影像消失后，人眼仍能继续保留其影像0.1-0.4 秒左右的图像。</li>
<li>让观察者观察按时间重复的亮度脉冲，如果闪烁频率比较低，人眼就有一亮一暗的感觉。如果闪烁频率足够高，人眼看到的则是一个恒定的亮点。</li>
</ul>
<h3 id="小孔相机模型">小孔相机模型</h3>
<figure data-type="image" tabindex="1"><img src="https://adiaosdu.github.io/post-images/1648022628322.png" alt="" loading="lazy"></figure>
<h3 id="摄像机模型">摄像机模型</h3>
<figure data-type="image" tabindex="2"><img src="https://adiaosdu.github.io/post-images/1648022680425.png" alt="" loading="lazy"></figure>
<h3 id="图像的几何变换">图像的几何变换</h3>
<p>数字图像处理是借助于数字计算机来处理数字图像。它有两个主要应用领域：</p>
<ul>
<li>改善图示信息以便人们解释；</li>
<li>为存储 、 传输和表示而对数字图像进行处理 以便于机器自动理解</li>
</ul>
<p>几何变换改变一幅图像像素间的几何关系 将输入图像的像素位置映射到输出图像的相应位置<br>
<img src="https://adiaosdu.github.io/post-images/1648022880861.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023044906.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023131103.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023145463.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023149957.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023203885.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023219528.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023287363.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023295679.png" alt="" loading="lazy"></p>
<ul>
<li>降采样
<ul>
<li>即上面提到的放大操作，放大倍数应小于1</li>
<li>既可以采用前向变换，也可以采用后向变换。前向是由原图像选择像素点生成新图像；后向是在新图像每个像素点到原图像中采样。</li>
</ul>
</li>
</ul>
<h3 id="灰度变换">灰度变换</h3>
<ul>
<li>把单个像素的值映射到另一个值。只需要定义一个灰度变换的映射函数。</li>
</ul>
<h4 id="图像增强">图像增强</h4>
<p>图像中的细节分辨不清是由对比度的不足带来的；<br>
由于成像设备的非线性，图象记录设备动态范围太窄等因素，图像成像时曝光不足或过度</p>
<p>灰度变换实现图像增强的原理：</p>
<ul>
<li>按需扩展压缩图像的灰度等级；</li>
<li>将感兴趣的灰度范围扩展，相对抑制不感兴趣的灰度区域。<br>
<img src="https://adiaosdu.github.io/post-images/1648023917654.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648023953604.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024002783.png" alt="" loading="lazy"></li>
</ul>
<h3 id="幂律变换与伽马校正">幂律变换与伽马校正</h3>
<p><img src="https://adiaosdu.github.io/post-images/1648024163170.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024157436.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024167438.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024171762.png" alt="" loading="lazy"></p>
<h3 id="灰度直方图">灰度直方图</h3>
<p>直方图是数字图像处理中最简单且有效的工具，对图像的分析、观察直至处理，均离不开直方图；<br>
灰度直方图 是灰度等级的函数</p>
<ul>
<li>描述的是图像中该灰度等级的 像素个数</li>
<li>该灰度等级的 像素出现频率</li>
<li>横坐标表示灰度等级，纵坐标表示图像中该灰度等级出现的个数或该灰度级像素出现的频率</li>
<li>反映了图像灰度分布的情况；<br>
<img src="https://adiaosdu.github.io/post-images/1648024270089.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024308102.png" alt="" loading="lazy"></li>
</ul>
<h3 id="直方图均衡">直方图均衡</h3>
<p><img src="https://adiaosdu.github.io/post-images/1648024355268.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024369197.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024400355.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1648024405343.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[激光原理简介]]></title>
        <id>https://adiaosdu.github.io/post/3tCXrKoKD/</id>
        <link href="https://adiaosdu.github.io/post/3tCXrKoKD/">
        </link>
        <updated>2022-03-23T01:19:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>光的基本性质：波粒二象性。光具有波动性，光是一种电磁波。光具有粒子性，由光子组成。</li>
<li>黑体：任何温度下，完全吸收任何波长的电磁辐射而无任何反射的物体。</li>
<li>光的干涉：两列或几列光波在空间相遇时相互叠加，在某些区域始终加强，在另一些区域则始终削弱，形成稳定的强弱分布的现象，证实了光具有波动性。<br>
光在传播过程中，遇到障碍物或小孔时，光将偏离直线传播的路径而绕到障碍物后面传播的现象，叫光的衍射。</li>
<li>光与物质的相互作用有：自发辐射、受激辐射、受激吸收。普通光源中（自发辐射）占主要；激光器中（受激辐射）占主要。自发辐射的光子其相位、波长、频率等是不同的。而受激辐射的光子，其波长、相位等是完全相同的。</li>
<li>简答：自发辐射、受激辐射、受激吸收之间关系：在光和大量原子系统的相互作用中，三者是同时发生的。在单位体积中，在dt时间内，由高能级E2通过自发辐射和受激辐射而跃迁到低能级E1的原子数，应等于低能级E1吸收光子而跃迁到高能级E2的原子数。</li>
<li>光谱的（线型）和（宽度）与光的（时间相干性）直接相关。<br>
辐射与吸收中的光的频率并不是一个确定值，而是存在一定范围，所以我们要拿一个线型函数来修正能级上粒子数的变化概率。 这个频率宽度叫做增宽。<br>
相干性：空间任意两点光振动之间相互关联的程度</li>
<li>光的多普勒效应：随着光源和接收器的<strong>相对运动</strong>而发生光源的频率发生改变（频移）称为多普勒效应。运动对向接受体频率增高，背向接受体频率降低。火车来时音调高，火车去时音调低。</li>
<li>均匀增宽与非均匀增宽：<br>
均匀增宽：自然增宽和碰撞增宽中每一个原子所发的光对谱线内任一频率都有贡献，而且这个贡献对每个原子都是等同的，这种增宽为均匀增宽。<br>
非均匀增宽：不同粒子对谱线不同频率部分的贡献不同, 即可分辨谱线线型哪一频带是由哪些特定粒子发射的(∵热运动速度矢量相同的粒子引起的频移相同)</li>
<li>实现光的放大的条件：</li>
</ol>
<ul>
<li>需要一个激励能源，用于把介质的粒子不断地由低能级抽送到高能级上去；</li>
<li>需要合适的发光介质（激光工作物质），它能在激励能源的作用下形成粒子数密度反成分布状态，并能保持一段时间。</li>
</ul>
<ol start="8">
<li>产生激光的条件：</li>
</ol>
<ul>
<li>有提供放大作用的增益介质作为激光工作物质，其激活粒子（原子、分子或离子）有适合于产生受激辐射的能级结构；</li>
<li>有外界激励源，将下能级的粒子抽运到上能级，使激光上下能级之间产生粒子数反转；</li>
<li>有光学谐振腔，增长激光介质的工作长度，控制光束的传播方向，选择被放大的受激辐射光频率以提高单色性。</li>
</ul>
<ol start="9">
<li>光学谐振腔通常都是由相隔一定距离的两块平行反射镜组成。无论是平面镜还是球面镜，也无论是凸面镜还是凹面镜，都可以用“共轴球面”模型来表示。</li>
</ol>
<ul>
<li>共轴：两块反射镜共轴</li>
<li>球面腔：两块反射镜都是球面镜(平面镜是半径为无穷大的球面镜)</li>
<li>稳定腔，不稳定腔：在光学谐振腔中，任一束傍轴光线在两反射镜之间来回不断反射，光在腔内来回反射过程中始终不离开谐振腔，使激光器能稳定的发射激光。满足这一要求的腔称为稳定腔。反之为不稳定腔。</li>
<li>不稳定腔有很大的几何损耗</li>
</ul>
<ol start="10">
<li>三能级系统与四能级系统（工作原理、示意图与优缺点）：</li>
</ol>
<ul>
<li>实现上下能级之间粒子数反转产生激光的物理过程：三能级系统和四能级系统</li>
<li>三能级系统：下能级E1是基态能级，上能级E2是亚稳态能级，E3为抽运高能级。其主要特征是激光的下能级为基态，发光过程中下能级的粒子数一直保存有相当的数量。</li>
<li>四能级系统：下能级E1不是基态能级，而是一个激发态能级，在常温下基本上是空的。其激励能量要比三能级系统小得多，产生激光要比三能级系统容易得多。<br>
<img src="https://adiaosdu.github.io/post-images/1648000935886.png" alt="" loading="lazy"><br>
辅助理解：（获得激光需要激光上下能级形成粒子数反转，也就是上能级粒子数大于下能级粒子数。泵浦粒子数到上能级是需要消耗能量的。三能级系统的下能级是基级，必须将一半以上的粒子数泵浦到高能级上。而四能级系统的下能级不是基态，可以很快排空，更容易形成粒子数反转。）</li>
</ul>
<ol start="11">
<li>激光器的损耗（镜面损耗），（内部损耗）。<br>
内部损耗：增益介质内部由于成分不均匀、粒子数密度不均匀或有缺陷而使光产生折射、散射等使部分光波偏离原来的传播方向，造成光能量的损耗。<br>
镜面损耗：当强度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>的光波射到镜面上，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">r_1I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>(或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>2</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">r_2I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>)反射回腔内继续放大，其它的部分均为损耗，包括<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">t_1I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>(或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">t_2I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>)、镜面的散射、吸收以及由于光的衍射使光束扩散到反射镜范围以外造成的损耗，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">a_1I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>(或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mi>I</mi></mrow><annotation encoding="application/x-tex">a_2I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>)表示。</li>
<li>自再现模：当两个镜面完全相同时（对称开腔），这种稳态场分布应在腔内经单程渡（传播）后，即可实现再现，这个稳定的横向场分布，就是激光谐振腔的自再现模。<br>
辅助理解：<br>
镜1上的场分布，到达镜2时，由于衍射，要经历一次能量的损耗和场分布的变化，中间能量损失小，镜边缘损失大，每单程渡越一次，都会发生类似的能量损耗和场分布变化，多次往返后，从而逐渐形成中间强、边缘弱的基本不受衍射影响的稳态场分布，该稳态场分布一个往返后可“自再现”出发时的场分布，唯一变化是镜面上各点的场振幅按同样的比例衰减，各点相位发生同样大小的滞后。<br>
横向场振幅分布和相位分布都均匀的平面波入射，经过多次孔阑的衍射影响后，二者都变得不再均匀，成为相对场振幅和相对相位分布都不受衍射影响的稳态场分布。（光波不断衍射后，边缘处光强减弱，使光强分布不断改变，振幅和相位分布逐次发生畸变，并最后趋向一定的稳定分布。</li>
<li>输出功率与诸参量之间的关系</li>
</ol>
<ul>
<li>输出功率P与饱和光强Is的关系: 两者成正比</li>
<li>输出功率P与光束截面A的关系: A越大，P越大；而高阶横模的光束截面要比基横的大</li>
<li>输出功率P与输出反射镜的透射率t1的关系: 实际中总是希望输出功率大镜面损耗小，这要求t1大，a1（反射镜镜面损耗系数）小，使t1&gt;&gt;a1，但
<ul>
<li>t1过大又使增益系数的阈值G阈升高，而如果介质的双程增益系数2LG0不够大将会导致腔内光强减小，使输出功率降低。严重时使腔内不能形成激光。</li>
<li>t1过小，虽然使G阈降低光强增强，但镜面损耗a1I-(2L)也将增大。<br>
最佳透射率：<br>
为了使激光器有最大的输出功率，必须使部分反射镜的透射率取最佳值，实际工作中总是用实验方法确定最佳透射率，再估计镜面损耗大小。</li>
</ul>
</li>
</ul>
<ol start="14">
<li>激光器输出的选模（选频）技术分为两个部分：1）激光纵模的选取，2）激光横模的选取。前者对激光输出频率影响较大，能够大大提高激光的相干性，常常叫做激光的选频技术；后者主要影响激光输出的光强均匀性，提高激光的亮度，一般称为选模技术。</li>
<li>纵模的竞争：通过增益的饱和效应，使某个纵模逐渐把别的纵模的振荡抑制下去，最后只剩下该纵模的振荡的现象叫做“纵模的竞争”。空间竞争：在均匀增宽激光器中，当受激辐射比较强时，也可能有比较弱的其它纵模出现，这种现象称为模式的“空间竞争”。</li>
<li>衍射损耗：通过求解激光谐振腔的自再现模积分方程得到，在激光谐振腔内振荡的基横模是高斯光束，其光振幅和光强分布在与光轴垂直的平面上呈高斯函数形式，一直延伸到离光轴无限远处。因此，由于反射镜的有限尺寸的限制，每一次反射都会有一部分光能衍射到镜面之外，造成能量损失。这种由于衍射效应形成的光能量损失称为衍射损耗。</li>
<li>腔内望远镜法优点： (1)能充分利用激光工作物质，获得较大功率的基模输出。(2)可通过调节望远镜的离焦量得到热稳定性很好的激光输出。(3)输出光斑大小适当，不致损伤光学元件。</li>
<li>频率的漂移：一个激光器通过选模获得单频振荡后，由于内部和外界条件的变化，谐振频率仍然会在整个线型宽度内移动。这种现象叫做“频率的漂移”。</li>
<li>频率的稳定性包括两个方面：一是频率稳定度；二是频率复现性。 影响频率稳定的因素：1）腔长L变化的影响  2）折射率变化的影响。<br>
稳频方法：</li>
</ol>
<ul>
<li>被动式稳频：利用热膨胀系数低的材料制作谐振腔的间隔器；或用膨胀系数为负值的材料和膨胀系数为正值的材料按一定长度配合，以使热膨胀互相抵消，实现稳频。<br>
-主动式稳频：目前采用的主动稳频方法基本原理大体相同，即把单频激光器的频率与某个稳定的参考频率相比较，当振荡频率偏离参考频率时，鉴别器就产生一个正比于偏离量的误差信号。这个误差信号经放大后又通过反馈系统返回来控制腔长，使振荡频率回到标准的参考频率上，实现稳频。</li>
</ul>
<ol start="20">
<li>实现激光偏转的途径：主要有机械偏转、电光偏转和声光偏转等。</li>
</ol>
<ul>
<li>机械偏转<br>
机械偏转是利用反射镜或多面反射棱镜的旋转或反射镜的振动实现光束扫描。优点：偏转角大、分辨率高、光损失少且可适应光谱范围大的优点。缺点：扫描速度受到驱动器(如马达)角速度的限制难以实现快速、高精度的可控偏转，使其应用范围受到限制。</li>
<li>电光偏转<br>
电光偏转是利用泡克耳斯效应，通过施加在电光晶体上的电场改变晶体的折射率，使光束偏转。<br>
因而出射光偏转角的改变量与折射率变化成线性关系。<br>
缺点：不能形成大的折射率梯度，即使采用多级电光棱镜的偏转器，偏转角也不会很大。</li>
<li>声光偏转<br>
声光效应也提供了一种方便地控制光的强度、频率和传播方向的手段，和电光效应一样得到了广泛的应用。</li>
</ul>
<ol start="21">
<li>调Q原理与方法：<br>
共振腔的Q值大小，是由腔内损耗和反射镜光学反馈能力两个因素所决定的；Q值愈高,所需要的泵浦阈值就越低，亦即激光愈容易起振。在一般的脉冲固体激光器的情况下，若不采用特殊的技术措施，脉冲激光在腔内的振荡持续时间，与光泵脉冲时间（毫秒量级左右）大致相同，因此输出激光的脉冲功率水平亦总是有限的。如果采用一种特殊的技术，使光泵脉冲开始后相当长一段时间内，有意降低共振腔的Q值而不产生激光振荡,则工作物质内的粒子数反转程度会不断通过光泵积累而增大；然后在某一特殊选定的时刻，突然快速增大共振腔的Q值,使腔内迅速发生激光振荡，积累到较高程度的反转粒子数能量会集中在很短的时间间隔内快速释放出来，从而可获得很窄脉冲宽度和高峰值功率的激光输出。为实现以上目的，最常用的方法是在共振腔内引入一个快速光开关──Q开关,它在光泵脉冲开始后的一段时间内处于“关闭”或“低Q”状态，此时腔内不能形成振荡而粒子数反转不断得到增强；在粒子数反转程度达到最大时,腔内Q开关突然处于“接通”或“高Q”状态,从而在腔内形成瞬时的强激光振荡,并产生所谓的调Q激光脉冲输出到腔外。<br>
总结激光调Q技术：用调节谐振腔的Q值以获得激光巨脉冲的技术。<br>
调Q原理：采用某种办法使谐振腔在泵浦开始时处于高损耗低Q值状态，这时激光振荡的阈值很高，粒子密度反转数即使积累到很高水平也不会产生振荡；当粒子密度反转数达到其峰值时，突然使腔的Q值增大，导致激光介质的增益将大大超过阈值，极其快速地产生振荡。这时贮存在亚稳态上的粒子所具有的能量会很快转换为光子的能量，光子像雪崩一样以极高的速率增长，激光器便可输出一个峰值功率高、宽度窄的激光巨脉冲。</li>
<li>调Q技术类型：因为谐振腔的损耗包括反射损耗、吸收损耗、衍射损耗、散射损耗和透射损耗，因而用不同方法控制不同类型的损耗，就形成了不同的调Q技术。控制反射损耗的有（机械转镜调Q技术）、（电光调Q技术），控制吸收损耗的有（可饱和吸收染料调Q技术），控制衍射损耗的有（声光调Q技术）等等。</li>
<li>各种调Q原理</li>
</ol>
<ul>
<li>电光调Q<br>
电光调Q是利用晶体的电光效应来作为Q开关的元件。</li>
<li>声光调Q<br>
在激光谐振腔内放置声光偏转器，当光通过介质中的超声场时，由于衍射造成光的偏折，就会增加损耗而改变腔的Q值。这种方法具有重复频率高和输出稳定等优点，目前，多用于获得中等功率的高重复频率的脉冲激光器中。</li>
<li>染料调Q<br>
利用某种材料(通常是用有机染料)对光的吸收系数会随光强变化的特性来达到调Q的目的。</li>
</ul>
<ol start="24">
<li>主动锁模：在谐振腔内插入一个调制频率为 调制器，对激光输出进行振幅或位相调制，实现各个纵模振动同步，叫做主动锁模。锁模类型：1）损耗内调制锁模2）位相内调制锁模</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MCMC——蒙特卡罗方法]]></title>
        <id>https://adiaosdu.github.io/post/Cm_rd5bIs1/</id>
        <link href="https://adiaosdu.github.io/post/Cm_rd5bIs1/">
        </link>
        <updated>2022-03-22T02:37:37.000Z</updated>
        <content type="html"><![CDATA[<p>作为一种随机采样方法，马尔科夫链蒙特卡罗（Markov Chain Monte Carlo，以下简称MCMC）在机器学习,深度学习以及自然语言处理等领域都有广泛的应用，是很多复杂算法求解的基础。比如我们前面讲到的分解机(Factorization Machines)推荐算法，还有前面讲到的受限玻尔兹曼机（RBM）原理总结，都用到了MCMC来做一些复杂运算的近似求解。下面我们就对MCMC的原理做一个总结。</p>
<h3 id="mcmc概述">MCMC概述</h3>
<p>从名字我们可以看出，MCMC由两个MC组成，即蒙特卡罗方法（Monte Carlo Simulation，简称MC）和马尔科夫链（Markov Chain ，也简称MC）。要弄懂MCMC的原理我们首先得搞清楚蒙特卡罗方法和马尔科夫链的原理。我们将用三篇来完整学习MCMC。在本篇，我们关注于蒙特卡罗方法。</p>
<h3 id="蒙特卡罗方法引入">蒙特卡罗方法引入</h3>
<p>蒙特卡罗原来是一个赌场的名称，用它作为名字大概是因为蒙特卡罗方法是一种随机模拟的方法，这很像赌博场里面的扔骰子的过程。最早的蒙特卡罗方法都是为了求解一些不太好求解的求和或者积分问题。<br>
对于某个定积分，一种计算的思路是采样离散化进行计算。虽然这种方法可以一定程度上求解出近似的解，但是它隐含了一个假定，即x在[a,b]之间是均匀分布的，而绝大部分情况，x在[a,b]之间不是均匀分布的。如果我们用上面的方法，则模拟求出的结果很可能和真实值相差甚远。</p>
<p>怎么解决这个问题呢？ 如果我们可以得到x在[a,b]的概率分布函数p(x)，那么我们的定积分求和可以这样进行：<br>
<img src="https://adiaosdu.github.io/post-images/1647917055840.png" alt="" loading="lazy"><br>
上式最右边的这个形式就是蒙特卡罗方法的一般形式。当然这里是连续函数形式的蒙特卡罗方法，但是在离散时一样成立。</p>
<p>可以看出，最上面我们假设x在[a,b]之间是均匀分布的时候，p(xi)=1/(b−a)，带入我们有概率分布的蒙特卡罗积分的上式，可以得到：<br>
<img src="https://adiaosdu.github.io/post-images/1647917236396.png" alt="" loading="lazy"><br>
也就是说，均匀分布也可以作为一般概率分布函数p(x)在均匀分布时候的特例。那么我们现在的问题转到了如何求出x的分布p(x)对应的若干个样本上来。</p>
<h3 id="概率分布采样">概率分布采样</h3>
<p>对于常见的均匀分布uniform(0,1)是非常容易采样样本的，一般通过线性同余发生器可以很方便的生成(0,1)之间的伪随机数样本。而其他常见的概率分布，无论是离散的分布还是连续的分布，它们的样本都可以通过uniform(0,1)的样本转换而得。比如二维正态分布的样本(Z1,Z2)可以通过通过独立采样得到的uniform(0,1)样本对(X1,X2)通过如下的式子转换而得：<br>
<img src="https://adiaosdu.github.io/post-images/1647917301337.png" alt="" loading="lazy"><br>
其他一些常见的连续分布，比如t分布，F分布，Beta分布，Gamma分布等，都可以通过类似的方式从uniform(0,1)得到的采样样本转化得到。在python的numpy，scikit-learn等类库中，都有生成这些常用分布样本的函数可以使用。</p>
<p>不过很多时候，我们的x的概率分布不是常见的分布，这意味着我们没法方便的得到这些非常见的概率分布的样本集。那这个问题怎么解决呢？</p>
<h3 id="接受-拒绝采样">接受-拒绝采样</h3>
<p>对于概率分布不是常见的分布，一个可行的办法是采用接受-拒绝采样来得到该分布的样本。既然 p(x) 太复杂在程序中没法直接采样，那么我设定一个程序可采样的分布 q(x) 比如高斯分布，然后按照一定的方法拒绝某些样本，以达到接近 p(x) 分布的目的，其中q(x)叫做 proposal distribution。<br>
<img src="https://adiaosdu.github.io/post-images/1647917357701.png" alt="" loading="lazy"><br>
具体采用过程如下，设定一个方便采样的常用概率分布函数 q(x)，以及一个常量 k，使得 p(x) 总在 kq(x) 的下方。如上图。</p>
<p>首先，采样得到q(x)的一个样本z0。然后，从均匀分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>k</mi><mi>q</mi><mo>(</mo><msub><mi>z</mi><mn>0</mn></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,kq(z_0))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>中采样得到一个值u。如果u落在了上图中的灰色区域，则拒绝这次抽样，否则接受这个样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">z_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。重复以上过程得到n个接受的样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>z</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>z</mi><mrow><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">z_0,z_1,...z_{n−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,则最后的蒙特卡罗方法求解结果为：<br>
<img src="https://adiaosdu.github.io/post-images/1647917458465.png" alt="" loading="lazy"><br>
整个过程中，我们通过一系列的接受拒绝决策来达到用q(x)模拟p(x)概率分布的目的。</p>
<h3 id="蒙特卡罗方法小结">蒙特卡罗方法小结</h3>
<p>使用接受-拒绝采样，我们可以解决一些概率分布不是常见的分布的时候，得到其采样集并用蒙特卡罗方法求和的目的。但是接受-拒绝采样也只能部分满足我们的需求，在很多时候我们还是很难得到我们的概率分布的样本集。比如：</p>
<ul>
<li>对于一些二维分布p(x,y)，有时候我们只能得到条件分布p(x|y)和p(y|x)和,却很难得到二维分布p(x,y)一般形式，这时我们无法用接受-拒绝采样得到其样本集。</li>
<li>对于一些高维的复杂非常见分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x_1,x_2,...,x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，我们要找到一个合适的q(x)和k非常困难。</li>
<li>从上面可以看出，要想将蒙特卡罗方法作为一个通用的采样模拟求和的方法，必须解决如何方便得到各种复杂概率分布的对应的采样样本集的问题。而我们下一篇要讲到的马尔科夫链就是帮助找到这些复杂概率分布的对应的采样样本集的白衣骑士。下一篇我们来总结马尔科夫链的原理。</li>
</ul>
<blockquote>
<p>本文转载自<br>
https://www.cnblogs.com/pinard/p/6625739.html<br>
转载请注明原出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离群点检测——孤立森林算法]]></title>
        <id>https://adiaosdu.github.io/post/TCUMQ2Tep/</id>
        <link href="https://adiaosdu.github.io/post/TCUMQ2Tep/">
        </link>
        <updated>2022-03-15T01:36:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>工作的过程中经常会遇到这样一个问题，在构建模型训练数据时，我们很难保证训练数据的纯净度，数据中往往会参杂很多被错误标记噪声数据，而数据的质量决定了最终模型性能的好坏。如果进行人工二次标记，成本会很高，我们希望能使用一种无监督算法帮我们做这件事，异常检测算法可以在一定程度上解决这个问题。</p>
<p>异常检测分为 离群点检测(outlier detection) 以及 奇异值检测(novelty detection) 两种.</p>
<ul>
<li>离群点检测：适用于训练数据中包含异常值的情况，例如上述所提及的情况。离群点检测模型会尝试拟合训练数据最集中的区域，而忽略异常数据。</li>
<li>奇异值检测：适用于训练数据不受异常值的污染，目标是去检测新样本是否是异常值。 在这种情况下，异常值也被称为奇异点。<br>
孤立森林 (Isolation Forest, iForest)是一个基于Ensemble的快速离群点检测方法，具有线性时间复杂度和高精准度，是符合大数据处理要求的State-of-the-art算法。由南京大学周志华教授等人于2008年首次提出，之后又于2012年提出了改进版本。适用于连续数据(Continuous numerical data)的异常检测，与其他异常检测算法通过距离、密度等量化指标来刻画样本间的疏离程度不同，孤立森林算法通过对样本点的孤立来检测异常值。具体来说，该算法利用一种名为孤立树iTree的二叉搜索树结构来孤立样本。由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。此外，相较于LOF，K-means等传统算法，孤立森林算法对高纬数据有较好的鲁棒性。其可以用于网络安全中的攻击检测，金融交易欺诈检测，疾病侦测，和噪声数据过滤等。</li>
</ul>
<p>举个例子：<br>
对于如何查找哪些点是否容易被孤立，iForest使用了一套非常高效的策略。假设我们用一个随机超平面来切割数据空间, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间了。上图里面黑色的点就很容易被切几次就停到一个子空间，而白色点聚集的地方可以切很多次才停止。</p>
<h2 id="算法">算法</h2>
<p>怎么来切这个数据空间是iForest的设计核心思想，本文仅介绍最基本的方法。由于切割是随机的，所以需要用Ensemble的方法来得到一个收敛值（蒙特卡洛方法），即反复从头开始切，然后平均每次切的结果。iForest 由 T 个 iTree 组成，每个 iTree 是一个二叉树结构。该算法大致可以分为两个阶段，第一个阶段我们需要训练出 T 颗孤立树，组成孤立森林。随后我们将每个样本点带入森林中的每棵孤立树，计算平均高度，之后再计算每个样本点的异常值分数。</p>
<h3 id="第一阶段">第一阶段：</h3>
<ul>
<li>从训练数据中随机选择Ψ个点样本点作为样本子集，放入树的根节点。</li>
<li>随机指定一个维度（特征），在当前节点数据中随机产生一个切割点 p（切割点产生于当前节点数据中指定维度的最大值和最小值之间）。</li>
<li>以此切割点生成了一个超平面，然后将当前节点数据空间划分为2个子空间：把指定维度里小于 p 的数据放在当前节点的左子节点，把大于等于 p 的数据放在当前节点的右子节点。</li>
<li>在子节点中递归步骤(2)和(3)，不断构造新的子节点，直到子节点中只有一个数据（无法再继续切割）或子节点已到达限定高度。</li>
<li>循环(1)至(4)，直至生成 T 个孤立树iTree。</li>
</ul>
<h3 id="第二阶段">第二阶段：</h3>
<p>获得T个iTree之后，iForest训练就结束，然后我们可以用生成的iForest来评估测试数据了。对于每一个数据点 x_i，令其遍历每一颗孤立树iTree，计算点 x_i 在森林中的平均高度 h(x_i) ，对所有点的平均高度做归一化处理。异常值分数的计算公式如下所示：<br>
<img src="https://adiaosdu.github.io/post-images/1647308422176.png" alt="" loading="lazy"></p>
<p>示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from sklearn.ensemble import IsolationForest
&gt;&gt;&gt; X = [[-1.1], [0.3], [0.5], [100]]
&gt;&gt;&gt; clf = IsolationForest(random_state=0).fit(X)
&gt;&gt;&gt; clf.predict([[0.1], [0], [90]])
array([ 1,  1, -1])
</code></pre>
<h2 id="补充">补充：</h2>
<p>iForest具有线性时间复杂度。因为是Ensemble的方法，所以可以用在含有海量数据的数据集上面。通常树的数量越多，算法越稳定。由于每棵树都是互相独立生成的，因此可以部署在大规模分布式系统上来加速运算。</p>
<p>iForest不适用于特别高维的数据。由于每次切数据空间都是随机选取一个维度，建完树后仍然有大量的维度信息没有被使用，导致算法可靠性降低。高维空间还可能存在大量噪音维度或无关维度(irrelevant attributes)，影响树的构建。对这类数据，建议使用子空间异常检测(Subspace Anomaly Detection)技术。此外，切割平面默认是axis-parallel的，也可以随机生成各种角度的切割平面，详见“On Detecting Clustered Anomalies Using SCiForest”。</p>
<p>iForest仅对Global Anomaly敏感，即全局稀疏点敏感，不擅长处理局部的相对稀疏点(Local Anomaly)。目前已有改进方法发表于PAKDD，详见“Improving iForest with Relative Mass”。</p>
<p>iForest推动了重心估计(Mass Estimation)理论发展，目前在分类聚类和异常检测中都取得显著效果，发表于各大顶级数据挖掘会议和期刊(如SIGKDD，ICDM，ECML)。</p>
<blockquote>
<p>本文转载自<br>
https://www.cnblogs.com/guoyaohua/p/isolation_forest.html<br>
转载请注明原出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[迁移学习简介]]></title>
        <id>https://adiaosdu.github.io/post/X6D9gk5lG/</id>
        <link href="https://adiaosdu.github.io/post/X6D9gk5lG/">
        </link>
        <updated>2022-03-14T02:45:03.000Z</updated>
        <content type="html"><![CDATA[<p>迁移学习(transfer learning)通俗来讲，就是运用已有的知识来学习新的知识，核心是找到已有知识和新知识之间的相似性，用成语来说就是举一反三。由于直接对目标域从头开始学习成本太高，我们故而转向运用已有的相关知识来辅助尽快地学习新知识。比如，已经会下中国象棋，就可以类比着来学习国际象棋；已经会编写Java程序，就可以类比着来学习C#；已经学会英语，就可以类比着来学习法语；等等。世间万事万物皆有共性，如何合理地找寻它们之间的相似性，进而利用这个桥梁来帮助学习新知识，是迁移学习的核心问题。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jindongwang/transferlearning/master/png/tf.png" alt="图1不同位置、不同传感器的迁移标定。已知一个房间中A点的WiFi信号与相应的人体行为，如何标定另一个房间中C点的蓝牙信号？" loading="lazy"></figure>
<p>图1不同位置、不同传感器的迁移标定。已知一个房间中A点的WiFi信号与相应的人体行为，如何标定另一个房间中C点的蓝牙信号？</p>
<p>具体地，在迁移学习中，我们已有的知识叫做源域(source domain)，要学习的新知识叫目标域(target domain)。迁移学习研究如何把源域的知识迁移到目标域上。特别地，在机器学习领域中，迁移学习研究如何将已有模型应用到新的不同的、但是有一定关联的领域中。传统机器学习在应对数据的分布、维度，以及模型的输出变化等任务时，模型不够灵活、结果不够好，而迁移学习放松了这些假设。在数据分布、特征维度以及模型输出变化条件下，有机地利用源域中的知识来对目标域更好地建模。另外，在有标定数据缺乏的情况下，迁移学习可以很好地利用相关领域有标定的数据完成数据的标定。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/jindongwang/transferlearning/master/png/tf2.png" alt="" loading="lazy"></figure>
<p>图2 迁移学习与传统机器学习的不同。(a)传统机器学习对不同的学习任务建立不同的模型，(b)迁移学习利用源域中的数据将知识迁移到目标域，完成模型建立。插图来自：Sinno Jialin Pan and Qiang Yang, A survey on transfer learning. IEEE TKDE 2010.</p>
<p>迁移学习按照学习方式可以分为基于样本的迁移，基于特征的迁移，基于模型的迁移，以及基于关系的迁移。基于样本的迁移通过对源域中有标定样本的加权利用完成知识迁移；基于特征的迁移通过将源域和目标域映射到相同的空间（或者将其中之一映射到另一个的空间中）并最小化源域和目标域的距离来完成知识迁移；基于模型的迁移将源域和目标域的模型与样本结合起来调整模型的参数；基于关系的迁移则通过在源域中学习概念之间的关系，然后将其类比到目标域中，完成知识的迁移。</p>
<p>理论上，任何领域之间都可以做迁移学习。但是，如果源域和目标域之间相似度不够，迁移结果并不会理想，出现所谓的负迁移情况。比如，一个人会骑自行车，就可以类比学电动车；但是如果类比着学开汽车，那就有点天方夜谭了。如何找到相似度尽可能高的源域和目标域，是整个迁移过程最重要的前提。</p>
<p>迁移学习方面，代表人物有香港科技大学的Qiang Yang教授，南洋理工大学的Sinno Jialin Pan，以及第四范式的CEO戴文渊等。代表文献是Sinno Jialin Pan和Qiang Yang的A survey on transfer learning。</p>
<p>[参考资料]<br>
[1] Pan S J, Yang Q. A survey on transfer learning[J]. IEEE Transactions on knowledge and data engineering, 2010, 22(10): 1345-1359.<br>
[2] Introduction to Transfer Learning: http://jd92.wang/assets/files/l03_transferlearning.pdf。<br>
[3] Qiang Yang: http://www.cse.ust.hk/~qyang/.<br>
[4] Sinno Jialin Pan: http://www.ntu.edu.sg/home/sinnopan/.<br>
[5] Wenyuan Dai: https://scholar.google.com/citations?user=AGR9pP0AAAAJ&amp;hl=zh-CN.</p>
<blockquote>
<p>本文转载自<br>
https://github.com/jindongwang/transferlearning<br>
转载请注明原出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSL/TLS协议运行机制]]></title>
        <id>https://adiaosdu.github.io/post/sDe7ttOaF/</id>
        <link href="https://adiaosdu.github.io/post/sDe7ttOaF/">
        </link>
        <updated>2022-03-11T05:45:13.000Z</updated>
        <content type="html"><![CDATA[<p>本文转载并修改自阮一峰的网络日志：https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</p>
<h2 id="一-作用">一、作用</h2>
<p>SSL工作在应用层，用于保证HTTP通信的安全性。访问协议https<br>
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>
（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>
（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：<br>
（1） 所有信息都是加密传播，第三方无法窃听。<br>
（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。<br>
（3） 配备身份证书，防止身份被冒充。</p>
<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h2 id="二-历史">二、历史</h2>
<p>互联网加密通信协议的历史，几乎与互联网一样长。<br>
1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br>
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br>
1996年，SSL 3.0版问世，得到大规模应用。<br>
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。<br>
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</p>
<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。<br>
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>
<h2 id="三-基本的运行过程">三、基本的运行过程</h2>
<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？<br>
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<p>（2）公钥加密计算量太大，如何减少耗用的时间？<br>
解决方法：每一次对话（session），客户端和服务器端都生成一个&quot;对话密钥&quot;（session key），用它来加密信息。由于&quot;对话密钥&quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&quot;对话密钥&quot;本身，这样就减少了加密运算的消耗时间。</p>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<p>（1） 客户端向服务器端索要并验证公钥。<br>
（2） 双方协商生成&quot;对话密钥&quot;。<br>
（3） 双方采用&quot;对话密钥&quot;进行加密通信。</p>
<p>上面过程的前两步，又称为&quot;握手阶段&quot;（handshake）。</p>
<h2 id="四-握手阶段的详细过程">四、握手阶段的详细过程</h2>
<p>&quot;握手阶段&quot;涉及四次通信。需要注意的是，&quot;握手阶段&quot;的所有通信都是明文的。</p>
<h3 id="41-客户端发出请求clienthello">4.1 客户端发出请求（ClientHello）</h3>
<p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。<br>
在这一步，客户端主要向服务器提供以下信息。<br>
（1） 支持的协议版本，比如TLS 1.0版。<br>
（2） 一个客户端生成的随机数，稍后用于生成&quot;对话密钥&quot;。<br>
（3） 支持的加密方法，比如RSA公钥加密。<br>
（4） 支持的压缩方法。</p>
<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p>
<h3 id="42-服务器回应severhello">4.2 服务器回应（SeverHello）</h3>
<p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<p>（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>
（2） 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。<br>
（3） 确认使用的加密方法，比如RSA公钥加密。<br>
（4） 服务器证书。</p>
<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供&quot;客户端证书&quot;。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h3 id="43-客户端回应">4.3 客户端回应</h3>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。<br>
（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>
（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>
（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称&quot;pre-master key&quot;。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把&quot;会话密钥&quot;。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。&quot;</p>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<h3 id="44-服务器的最后回应">4.4 服务器的最后回应</h3>
<p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&quot;会话密钥&quot;。然后，向客户端最后发送下面信息。</p>
<p>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。<br>
至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用&quot;会话密钥&quot;加密内容。</p>
<h2 id="总结ssl的四次握手">总结SSL的四次握手</h2>
<p>第一次握手：客户机发送访问请求和随机数1<br>
第二次握手：服务器回复自身证书和随机数2<br>
第三次握手：客户机验证证书，使用证书中的公钥加密一个随机数3并发送，随后用三个随机数生成会话密钥<br>
第四次握手：服务器用私钥解密随机数3，也生成会话密钥</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[华为公司介绍 汉译英 篇章练习]]></title>
        <id>https://adiaosdu.github.io/post/broRIsAXB/</id>
        <link href="https://adiaosdu.github.io/post/broRIsAXB/">
        </link>
        <updated>2022-03-10T04:39:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="华为创立于1987年是全球领先的-ict信息与通信基础设施和智能终端提供商公司致力于把数字世界带入每个人-每个家庭-每个组织构建万物互联的智能世界-目前华为有197万员工业务遍及170多个国家和地区服务30多亿人口">华为创立于1987年，是全球领先的 ICT（信息与通信）基础设施和智能终端提供商，公司致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界。目前华为有19.7万员工，业务遍及170多个国家和地区，服务30多亿人口。</h3>
<h3 id="tmp-huawei-which-was-established-in-1987-is-a-global-advanced-ict-infrastructure-and-intelligent-terminal-provider-the-company-devote-itself-to-bringing-the-digital-world-into-every-person-family-and-organization-and-constructing-a-intelligent-world-with-links-on-everything-today-with-197-thousand-stuffs-huaweis-business-holds-throughtout-more-than-170-countries-and-areas-serving-more-than-3-billion-people">TMP: Huawei, which was established in 1987, is a global advanced ICT infrastructure and intelligent terminal provider. The company devote itself to bringing the digital world into every person, family and organization and constructing a intelligent world with links on everything. Today, with 197 thousand stuffs, Huawei's business holds throughtout more than 170 countries and areas, serving more than 3 billion people.</h3>
<ul>
<li>Founded in 更简洁</li>
<li>world-leading 全球领先的</li>
<li>be committed to 致力于，承诺</li>
<li>make the digitial world accessible to xxx</li>
<li>这里面提到的家庭更适合用househole</li>
<li>so far 到目前为止</li>
<li>with a stuff of</li>
<li>前面用过了more than 后面用over更好</li>
</ul>
<h3 id="华为在通信网络-it-智能终端和云服务等领域为客户提供有竞争力-安全-可信赖的产品-解决方案与服务与生态伙伴开放合作持续为客户创造价值释放个人潜能丰富家庭生活激发组织创新-华为坚持围绕客户需求持续创新加大基础研究投人厚积薄发推动世界进步">华为在通信网络、IT、智能终端和云服务等领域为客户提供有竞争力、安全、可信赖的产品、解决方案与服务，与生态伙伴开放合作，持续为客户创造价值，释放个人潜能，丰富家庭生活，激发组织创新。 华为坚持围绕客户需求持续创新，加大基础研究投人，厚积薄发，推动世界进步。</h3>
<h3 id="tmp-huawei-provides-its-cilents-with-competitive-secure-and-trustworthy-products-solutions-and-services-making-open-collaborations-with-ecological-partners-creating-continuous-values-to-clients-releasing-pensonal-potency-enriching-family-life-and-inspiring-organizational-innovation">TMP: Huawei provides its cilents with competitive, secure and trustworthy products, solutions and services(), <s>making open collaborations with ecological partners</s>, creating continuous values <s>to</s> clients, releasing pensonal potency, enriching family life and inspiring organizational innovation.</h3>
<ul>
<li>在xxx领域 in areas of telecommunication networks, IT, smart terminals and cloud service.</li>
<li>后面也可以另起一句话</li>
<li>生态伙伴 eco-partners 开放地 inclusively</li>
<li>为xxx创造价值用 for</li>
<li>潜能，潜力 potential 这个词可以是名词也可以是形容词</li>
<li>stimulating 激发 刺激</li>
<li>innovation 和 creativity 都可以表示创新</li>
</ul>
<h3 id="ans-huawei-has-kept-focusing-on-the-needs-of-clients-and-innovated-continuously-it-has-increased-investment-in-fundamental-research-and-expanded-its-technological-accumulation-to-promote-the-progress-of-the-world">ANS: Huawei has kept focusing on the needs of clients and innovated continuously. It has increased investment in fundamental research and expanded its technological accumulation to promote the progress of the world.</h3>
<ul>
<li>这种复杂的并列句，很复杂的就拆开</li>
<li>加大科技积累 = 厚积薄发  关键其实还是积累</li>
</ul>
<h3 id="华为主张开放-合作共赢与客户-伙伴合作创新-扩大产业价值形成健康-良性的产业生态系统-华为加入400多个标准组织-产业联盟和开源社区积极参与和支持主流标准的制定推动产业良性发展推动社会可持续发展">华为主张开放、合作共赢，与客户、伙伴合作创新、扩大产业价值，形成健康、良性的产业生态系统。华为加入400多个标准组织、产业联盟和开源社区，积极参与和支持主流标准的制定，推动产业良性发展，推动社会可持续发展。</h3>
<h3 id="华为致力消除数字鸿沟-促进数字包容在珠峰-北极圈内等偏远地区建设网络在西非埃博拉疫区-日本海啸核泄露-中国汶川大地震等重大灾难现场恢复通信同时积极推进绿色低碳和节能环保帮助培养本地ict人才促进数字经济发展">华为致力消除数字鸿沟、促进数字包容，在珠峰、北极圈内等偏远地区建设网络，在西非埃博拉疫区、日本海啸核泄露、中国汶川大地震等重大灾难现场恢复通信；同时，积极推进绿色低碳和节能环保，帮助培养本地ICT人才，促进数字经济发展。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的聚类算法]]></title>
        <id>https://adiaosdu.github.io/post/1Rx3inNGH/</id>
        <link href="https://adiaosdu.github.io/post/1Rx3inNGH/">
        </link>
        <updated>2022-03-10T00:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>聚类算法都属于无监督学习算法。聚类算法的核心思想是使类内距离最大，类间距离最小。</p>
<h3 id="距离的定义">距离的定义</h3>
<p>欧氏距离、曼哈顿距离、、闵氏距离、马氏距离等<br>
<img src="https://adiaosdu.github.io/post-images/1646873842713.png" alt="" loading="lazy"></p>
<h2 id="基于中心点的聚类算法">基于中心点的聚类算法</h2>
<h3 id="代表为k-means">代表为K-means</h3>
<ul>
<li>K的值需要事先指定，提前告知要分成多少类</li>
<li>算法流程
<ul>
<li>随机选取K个中心点</li>
<li>对每个数据点，将其划作距其最近的一个中心点所在的类</li>
<li>所有数据点遍历完一遍后，重新计算各类的中心点</li>
<li>循环上面两步，直到收敛</li>
</ul>
</li>
<li>算法的有穷性和时间复杂度<br>
<img src="https://adiaosdu.github.io/post-images/1646874258810.png" alt="" loading="lazy"></li>
<li>K-means是一种不稳定的启发式算法。启发式算法相对于最优化算法，不是根据严格的数学理论和数学推导提出，而是基于经验和直觉。</li>
</ul>
<h3 id="基于概率的k-means算法">基于概率的K-means++算法</h3>
<figure data-type="image" tabindex="1"><img src="https://adiaosdu.github.io/post-images/1646874600507.png" alt="" loading="lazy"></figure>
<h3 id="k-means的限制">K-means的限制</h3>
<p><img src="https://adiaosdu.github.io/post-images/1646874729783.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646874736104.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646874741532.png" alt="" loading="lazy"></p>
<h3 id="优缺点">优缺点</h3>
<ul>
<li>优点：简单、收敛快、高效</li>
<li>缺点：事先指定k、可能局部最优、对噪音敏感、适用范围有限<br>
<img src="https://adiaosdu.github.io/post-images/1646874933136.png" alt="" loading="lazy"></li>
</ul>
<h2 id="基于连接关系的聚类算法">基于连接关系的聚类算法</h2>
<h3 id="距离定义">距离定义</h3>
<ul>
<li>如何定义两个类之间的距离？下面图中是一些常见的定义。<br>
<img src="https://adiaosdu.github.io/post-images/1646894082185.png" alt="" loading="lazy"></li>
</ul>
<h3 id="代表为层次聚类hierarchical">代表为层次聚类Hierarchical</h3>
<p>一开始每个样本各成一类<br>
每轮选择距离最近的两个类合并<br>
在最后所有的样本合成一类之前停止</p>
<h3 id="优缺点-2">优缺点</h3>
<p><img src="https://adiaosdu.github.io/post-images/1646894442799.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646894448244.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646894453505.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646894477164.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646894516302.png" alt="" loading="lazy"></p>
<h3 id="上面两种算法对比">上面两种算法对比</h3>
<figure data-type="image" tabindex="2"><img src="https://adiaosdu.github.io/post-images/1646894764932.png" alt="" loading="lazy"></figure>
<h2 id="基于密度的聚类算法">基于密度的聚类算法</h2>
<h3 id="代表为dbscan">代表为DBSCAN</h3>
<ul>
<li>直觉上判断，类簇区域应该是高密度的，噪音区域是低密度的</li>
<li>画圈，将点分为两类。core point圈内有足够点，border point自身圈内密度不够，但是属于core point的邻居。<br>
<img src="https://adiaosdu.github.io/post-images/1646895203141.png" alt="" loading="lazy"></li>
</ul>
<h3 id="density-reachability-密度可达">Density Reachability 密度可达</h3>
<p><img src="https://adiaosdu.github.io/post-images/1646895326853.png" alt="" loading="lazy"><br>
<img src="https://adiaosdu.github.io/post-images/1646895357099.png" alt="" loading="lazy"></p>
<ul>
<li>border poing 是由 core point 密度可达的</li>
<li>密度可达这种关系是可传递的</li>
</ul>
<h3 id="density-connectivity-密度相连">Density Connectivity 密度相连</h3>
<figure data-type="image" tabindex="3"><img src="https://adiaosdu.github.io/post-images/1646895501416.png" alt="" loading="lazy"></figure>
<h3 id="簇的定义">簇的定义</h3>
<figure data-type="image" tabindex="4"><img src="https://adiaosdu.github.io/post-images/1646895632981.png" alt="" loading="lazy"></figure>
<ul>
<li>簇内任意一点，密度可达的所有点也应在簇内</li>
<li>簇内任意两点间是密度相连的</li>
<li>噪声不属于任何一个簇</li>
</ul>
<h3 id="算法总结">算法总结</h3>
<figure data-type="image" tabindex="5"><img src="https://adiaosdu.github.io/post-images/1646895870928.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[云计算模型与基本概念]]></title>
        <id>https://adiaosdu.github.io/post/SPgT4hXpj/</id>
        <link href="https://adiaosdu.github.io/post/SPgT4hXpj/">
        </link>
        <updated>2022-03-08T10:35:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="角色与边界">角色与边界</h3>
<ul>
<li>与基于云的交互和关系相关的常见角色包括云提供者、云用户、云服务拥有者和云资源管理者。</li>
<li>组织边界(organizational boundary)：是一个物理范围，指由一家组织拥有和管理的IT资源集合。</li>
<li>组织边界表示该组织的IT资产和IT资源，不表示组织实际的边界。</li>
<li>信任边界(trust boundary)：是一个逻辑范围，通常会跨越物理边界，表明IT资源受信任的程度。</li>
<li>当组织角色是云用户时，要访问基于云的IT资源时，需要将信任扩展到该组织的物理边界之外，把部分云环境包括进来。</li>
</ul>
<h3 id="云特性">云特性</h3>
<ul>
<li>按需使用指云用户能够通过自主服务来使用所需的基于云的服务，而无需与云提供者交互。这一特性与可测量的使用有关，后者表示的是云对其IT资源使用进行测量的能力。</li>
<li>泛在接入即随处访问，允许基于云的服务能够被各种云服务用户访问，而多租户指一个IT资源的一个实例可以同时透明的服务多个云用户的能力。</li>
<li>弹性特性表示云能够透明的和自动的扩展IT资源。可恢复性与云内在的故障转移特性相关。</li>
</ul>
<h3 id="云交付模型">云交付模型</h3>
<ul>
<li>IaaS：基础设施可以包括硬件、网络、连通性、操作系统、以及其他一些原始的IT资源，这些资源是虚拟化的并打包成包，使得运行时扩展和定制基础设施变的简单。云用户使用IaaS环境中的虚拟服务器。云提供者向云用户提供了一组合约保证，这些保证是关于像容量、性能和可用性这样一些特性的。例如各大云服务厂商的云服务器租赁服务。</li>
<li>PaaS：是预先定义好的就绪可用(ready-to-use)的环境，一般由已经部署好和配置好的IT资源组成。例如Force和Google App Engine。
<ul>
<li>用户使用PaaS的常见原因包括：
<ul>
<li>为了可扩展性和经济原因，云用户想要把企业内的环境扩展到云中。</li>
<li>云用户使用已就绪环境来完全替代企业内的环境。</li>
<li>云用户想要成为云提供者并部署自己的云服务，使之对其他外部云用户可见。</li>
</ul>
</li>
</ul>
</li>
<li>SaaS：把软件程序定位成共享的云服务，作为“产品”或通用工具进行提供。云服务用户可以访问云服务，但是不能访问任何底层的IT资源或实现细节。例如：百度网盘，icloud等。<br>
<img src="https://adiaosdu.github.io/post-images/1646735970534.png" alt="" loading="lazy"></li>
</ul>
<h3 id="云部署模型">云部署模型</h3>
<ul>
<li>公有云(public cloud)：由第三方云提供者拥有的可公共访问的云环境。公有云里的IT资源通常是按照事先描述好的云交付模型提供的，一般需要付费才能提供给云用户使用。</li>
<li>社区云：类似于公有云，只是访问被限制在特定的云用户社区，社区云用户成员通常共同承担定义和发展社区云的责任。社区成员不一定能够访问或控制云中的所有IT资源。</li>
<li>私有云：由一家组织单独拥有。私有云使得组织把云计算技术当做一种手段，可以集中访问不同部分、位置或部门的IT资源。</li>
<li>混合云：由两个或者更多不同部署模型组成的云环境，如云用户把敏感信息部署在私有云，非敏感信息部署在公有云。</li>
<li>虚拟私有云：又称专有云或托管云，由公有云提供者托管或管理，仅对一个用户可用。</li>
<li>互联云：基于两个或更多互相连接起来的云组成的架构。</li>
</ul>
<blockquote>
<p>云计算技术栏目为山东大学计算机学院郑艳伟老师讲授的《云计算技术》课程笔记。栏目内容几乎全部来自课程课件，少部分来自互联网。<br>
该笔记重点整理课程及实际应用中涉及到的一些重要概念、算法和数据结构。此外自己也额外补充了一些内容。</p>
</blockquote>
]]></content>
    </entry>
</feed>